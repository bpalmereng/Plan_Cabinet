name: Publish Win-x64 with ReadyToRun

on:
  push:
    branches: [ master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-2022

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Install Windows MAUI workloads
        run: dotnet workload install maui-windows --include-previews

      - name: Import Signing Certificate
        shell: pwsh
        run: |
          $pfx_base64 = "${{ secrets.PFX_CERTIFICATE_BASE64 }}"
          $pfx_password = "${{ secrets.PFX_PASSWORD }}"
          $pfx_bytes = [System.Convert]::FromBase64String($pfx_base64)
          [System.IO.File]::WriteAllBytes("cert.pfx", $pfx_bytes)
          $pfx_password_secure = ConvertTo-SecureString -String $pfx_password -AsPlainText -Force
          Import-PfxCertificate -FilePath "cert.pfx" -CertStoreLocation Cert:\CurrentUser\My -Password $pfx_password_secure

      - name: Build and Package MAUI App for Windows
        shell: pwsh
        run: |
          dotnet publish -f net8.0-windows10.0.22000.0 -c Release -p:WindowsPackageType=MSIX -p:RuntimeIdentifier=win-x64 -p:Platform=x64 -p:PublishReadyToRun=false --self-contained true

      - name: Find Installer Package
        id: find_bundle
        shell: pwsh
        run: |
          $file = Get-ChildItem "Plan_Cabinet/bin/x64/Release/net8.0-windows10.0.22000.0/win-x64/AppPackages" -Recurse -Include *.msixbundle,*.msix | Where-Object { $_.DirectoryName -notlike "*Dependencies*" } | Select-Object -First 1
          if (-not $file) { Write-Error "❌ No installer package found!"; exit 1 }
          echo "bundle_path=$($file.FullName)" >> $env:GITHUB_OUTPUT

      - name: Bundle Installer Files and Create Executable
        id: bundle
        shell: pwsh
        run: |
          $appDir = Split-Path "${{ steps.find_bundle.outputs.bundle_path }}" -Parent
          $parentDir = Split-Path $appDir -Parent
          Write-Host "App directory: $appDir"

          $appxFilename = [System.IO.Path]::GetFileName("${{ steps.find_bundle.outputs.bundle_path }}")
          $cer  = Get-ChildItem $appDir -Filter "*.cer" | Select-Object -First 1
          if (-not $cer)  { Write-Error "❌ No certificate (.cer) found"; exit 1 }
          
          # Extract version from the appx filename
          $version = ($appxFilename -split "_")[1]
          Write-Host "Detected version: $version"

          # Generate .appinstaller file
          $appInstallerPath = Join-Path $appDir "Plan_Cabinet.appinstaller"
          $msixUri = "https://bpalmereng.github.io/Plan_Cabinet/$appxFilename"
          $appInstallerXml = @"
          <?xml version="1.0" encoding="utf-8"?>
          <AppInstaller Uri="$msixUri" Version="$version" xmlns="http://schemas.microsoft.com/appx/appinstaller/2017/2">
          <MainPackage Name="PlanCabinet" Publisher="CN=Brian Palmer - TCPW" Version="$version" Uri="$msixUri" />
          <UpdateSettings>
          <OnLaunch HoursBetweenUpdateChecks="0" />
          <AutomaticBackgroundTask />
          </UpdateSettings>
          </AppInstaller>
          "@
          Set-Content -Path $appInstallerPath -Value $appInstallerXml -Encoding UTF8

          # Batch installer
          $batScript = @"
          @echo off
          echo Checking for Windows App SDK Runtime...
          powershell -Command "if (-not (Get-AppxPackage -Name Microsoft.WindowsAppRuntime.1.4)) { Write-Host 'Windows App SDK Runtime not found. Downloading and installing...'; Invoke-WebRequest -Uri 'https://aka.ms/windowsappsdk/1.4/1.4.7/windowsappruntimeinstaller.exe' -OutFile 'windowsappruntimeinstaller.exe'; Start-Process -FilePath 'windowsappruntimeinstaller.exe' -ArgumentList '-quiet' -Wait; Remove-Item 'windowsappruntimeinstaller.exe' }"

          echo Installing certificate...
          powershell -ExecutionPolicy Bypass -Command "Add-Type -AssemblyName System.Security; `$cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2('.\$($cer.Name)'); `$store = New-Object System.Security.Cryptography.X509Certificates.X509Store('TrustedPeople', 'CurrentUser'); `$store.Open('ReadWrite'); `$existing = `$store.Certificates | Where-Object { `$_.Thumbprint -eq `$cert.Thumbprint }; foreach (`$c in `$existing) { `$store.Remove(`$c) }; `$store.Add(`$cert); `$store.Close(); Write-Host 'Certificate installed.'"

          echo Launching app installer...
          start "" "Plan_Cabinet.appinstaller"

          echo Installation process launched.
          pause
          "@
          Set-Content -Path "$appDir\Install-App.bat" -Value $batScript -Encoding ASCII
          
          # Create self-extracting executable config file
          $sfxConfig = @"
          ;!@Install@!UTF-8!
          RunProgram="Install-App.bat"
          ;!@Install@!
          "@
          Set-Content -Path "$appDir\sfx_config.txt" -Value $sfxConfig -Encoding ASCII

          # Create a self-extracting executable with version in the name
          $exePath = "$parentDir\Plan_Cabinet_Installer-$version.exe"
          & "C:\Program Files\7-Zip\7z.exe" a -sfx -y "$exePath" "$appDir\*" -r -spf2 -m0=lzma2
          
          echo "bundle_exe=$exePath" >> $env:GITHUB_OUTPUT

      - name: Upload Installer Executable
        uses: actions/upload-artifact@v4
        with:
          name: Plan_Cabinet-Installer-Bundle
          path: ${{ steps.bundle.outputs.bundle_exe }}
          retention-days: 7

  deploy-pages:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write

    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: Plan_Cabinet-Installer-Bundle

      - name: Create index.html with download link
        run: |
          FILE=$(ls *.exe 2>/dev/null | head -n 1)
          echo "<html><body><h1>Plan_Cabinet Installer</h1><p><a href=\"$FILE\">Download Installer</a></p></body></html>" > index.html

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: .

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4